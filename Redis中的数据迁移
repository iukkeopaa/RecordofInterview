在 Redis 集群中进行节点扩容时，重新分片（resharding）过程确实需要保证服务的连续性。Redis Cluster 通过**渐进式数据迁移**和**客户端重定向**机制实现了这一目标，下面为你详细介绍：

### **1. Redis 集群的分片原理**

Redis Cluster 采用**哈希槽（Hash Slot）\**机制进行数据分片，整个集群共有\**16384 个哈希槽**。每个节点负责处理一部分哈希槽，例如：

- 3 节点集群：每个节点负责约 5461 个哈希槽（16384 ÷ 3）。
- 扩容后（如 5 节点）：每个节点负责约 3277 个哈希槽（16384 ÷ 5）。

当添加新节点后，需要将部分哈希槽从现有节点迁移到新节点。

### **2. 重新分片的核心流程**

#### **2.1 准备阶段**

1. **添加新节点**：使用`redis-cli --cluster add-node`命令将新节点加入集群。此时新节点不负责任何哈希槽，处于 “接收” 状态。
2. **规划迁移**：使用`redis-cli --cluster reshard`命令指定需要迁移的哈希槽数量和目标节点。

#### **2.2 渐进式迁移**

Redis 通过**MOVED 和 ASK 重定向**机制实现迁移期间的服务连续性：

1. **迁移哈希槽**：

   - 源节点将哈希槽标记为 “迁移中”（migrating）。
   - 目标节点将哈希槽标记为 “导入中”（importing）。

2. **数据迁移**：

   - 源节点将哈希槽中的键逐个迁移到目标节点：

     bash

     

     

     

     

     

     ```bash
     # 1. 源节点执行：查询属于该哈希槽的部分键
     CLUSTER GETKEYSINSLOT <slot> <count>
     
     # 2. 源节点执行：将键迁移到目标节点
     MIGRATE <target_ip> <target_port> <key> <db> <timeout> COPY
     ```

   - 迁移期间，源节点和目标节点同时维护这些键。

3. **客户端重定向**：

   - **MOVED 错误**：若客户端访问的键已完全迁移，源节点返回`MOVED <slot> <target_ip>:<target_port>`，客户端需更新本地路由表并重试。
   - **ASK 错误**：若客户端访问的键正在迁移中，源节点返回`ASK <slot> <target_ip>:<target_port>`，客户端需先向目标节点发送`ASKING`命令，再重试操作。

### **3. 迁移期间的请求处理**

#### **3.1 客户端请求流程**

1. **正常请求**：客户端根据本地缓存的哈希槽 - 节点映射直接访问目标节点。

2. MOVED 重定向

   ：

   - 若键已迁移，源节点返回`MOVED`错误。
   - 客户端更新本地路由表，重新向目标节点发送请求。

3. ASK 重定向

   ：

   - 若键正在迁移中，源节点返回`ASK`错误。
   - 客户端先向目标节点发送`ASKING`命令（临时允许访问导入中的哈希槽），再重试请求。

#### **3.2 节点内部处理**

- 源节点

  ：

  - 对于已迁移的键，返回`MOVED`错误。
  - 对于未迁移的键，正常处理请求。

- 目标节点

  ：

  - 对于导入中的哈希槽，仅处理带有`ASKING`标志的请求。

### **4. 关键机制详解**

#### **4.1 客户端缓存与更新**

- **本地路由表**：客户端缓存哈希槽 - 节点映射关系，减少重定向次数。
- **动态更新**：当收到`MOVED`错误时，客户端更新本地路由表。

#### **4.2 ASKING 命令的作用**

- `ASKING`命令允许客户端临时访问 “导入中” 的哈希槽，避免正常请求被拒绝。
- 该标志仅对当前连接有效，请求完成后自动清除。

#### **4.3 数据一致性保障**

- **原子性迁移**：单个键的迁移是原子性的，迁移期间不会丢失数据。
- **双写机制**：迁移过程中，源节点和目标节点同时维护数据，确保读写一致性。

### **5. 扩容操作示例**

以下是扩容 Redis 集群的典型命令流程：

bash











```bash
# 1. 添加新节点到集群
redis-cli --cluster add-node <new_node_ip:port> <existing_node_ip:port>

# 2. 执行重新分片（假设迁移1000个哈希槽到新节点）
redis-cli --cluster reshard <existing_node_ip:port> \
  --cluster-slots 1000 \
  --cluster-to <new_node_id> \
  --cluster-from <source_node_id_1>,<source_node_id_2>... \
  --cluster-yes

# 3. 可选：检查分片状态
redis-cli -c -h <node_ip> -p <port> cluster nodes
```

### **6. 性能优化建议**

1. **控制迁移速度**：通过`cluster-node-timeout`参数调整节点超时时间，避免迁移过程中断。
2. **分批迁移**：对于大规模集群，分批次迁移哈希槽，避免集中负载。
3. **监控集群状态**：使用`CLUSTER INFO`和`CLUSTER NODES`命令实时监控迁移进度。
4. **读写分离**：在迁移高峰期，将读请求导向从节点，减轻主节点压力。

### **总结**

Redis Cluster 通过以下机制保证扩容期间的服务可用性：

- **渐进式迁移**：逐个键迁移，避免一次性全量数据迁移带来的性能抖动。
- **智能重定向**：通过`MOVED`和`ASK`错误引导客户端访问正确节点。
- **双写机制**：迁移期间源节点和目标节点同时维护数据，确保一致性。





在 Redis 集群扩容（节点添加与哈希槽重分配）过程中，服务连续性的核心保障依赖于**渐进式数据迁移**、**客户端重定向机制**以及**节点状态协同**三大核心设计，具体实现如下：

### **一、核心机制：渐进式数据迁移**

Redis 的哈希槽迁移不是一次性全量迁移，而是**逐个键、分批次**进行，避免因大量数据迁移导致服务中断。

- **迁移单位**：以哈希槽为最小单位，但每个哈希槽内的键会被分批迁移（每次迁移少量键，例如通过`CLUSTER GETKEYSINSLOT <slot> <count>`指定每次迁移的键数量）。

- 双节点暂存

  ：迁移过程中，源节点（原负责哈希槽的节点）和目标节点（新节点）会

  同时保留该键的数据

  ，直到迁移完成。

  - 未迁移的键：仍由源节点正常处理读写请求。
  - 已迁移的键：目标节点接管处理，源节点不再保留。

### **二、客户端与节点的协同：重定向机制**

迁移期间，客户端可能访问到 “正在迁移的哈希槽” 或 “已迁移的哈希槽”，此时 Redis 通过**MOVED**和**ASK**两种重定向命令，引导客户端访问正确的节点，避免请求失败。

#### **1. MOVED 重定向（已完成迁移的哈希槽）**

当某个哈希槽已完全从源节点迁移到目标节点：

- 客户端若仍向源节点请求该哈希槽的键，源节点会返回`MOVED <slot> <target_ip>:<target_port>`，告知客户端该哈希槽已归属新节点。
- 客户端收到后，会**更新本地缓存的哈希槽 - 节点映射表**，后续请求直接发送到目标节点。

#### **2. ASK 重定向（正在迁移的哈希槽）**

当某个哈希槽处于 “迁移中”（部分键已迁移，部分未迁移）：

- 客户端向源节点请求该哈希槽中**已迁移的键**时，源节点会返回`ASK <slot> <target_ip>:<target_port>`，告知客户端该键已临时转移到目标节点。
- 客户端收到后，需先向目标节点发送`ASKING`命令（临时允许访问 “导入中” 的哈希槽），再重新发送请求，目标节点会处理该请求。
- 注意：`ASK`是临时重定向，客户端不会更新本地映射表，下次请求仍可能先访问源节点（直到哈希槽完全迁移，触发`MOVED`后才更新）。

### **三、节点状态标记：迁移中的权责划分**

为避免迁移期间的请求混乱，源节点和目标节点会通过状态标记明确哈希槽的处理权限：

- 源节点

  ：将正在迁移的哈希槽标记为

  ```
  migrating
  ```

  （迁移中），此时：

  - 对于未迁移的键：正常处理读写。
  - 对于已迁移的键：返回`ASK`或`MOVED`重定向。

- 目标节点

  ：将正在接收的哈希槽标记为

  ```
  importing
  ```

  （导入中），此时：

  - 仅处理带有`ASKING`标志的请求（避免其他客户端误访问）。
  - 迁移完成后，标记为`active`（正常状态），正式接管该哈希槽。

### **四、数据一致性保障**

- **原子性迁移**：单个键的迁移是原子操作（通过`MIGRATE`命令实现），迁移期间不会出现键值丢失或部分写入的情况。

- 读写不中断

  ：

  - 读请求：无论键是否迁移，通过重定向总能找到正确的节点，返回最新数据。
  - 写请求：迁移中的键会被源节点拦截并转发到目标节点（或通过重定向让客户端直接写入目标节点），确保写入的数据最终存储在正确节点。

### **总结**

Redis 集群通过 **“渐进式迁移 + 双节点暂存 + 重定向引导 + 状态标记”** 的组合机制，在扩容过程中实现了服务的连续性：

- 迁移不中断正常请求，客户端通过重定向自动适配哈希槽的新归属。
- 数据在迁移前后均能被正确读写，且无丢失风险。
- 整个过程无需停止集群，对外服务完全透明。



Redis 集群在扩容时（添加新节点）进行数据重分配（槽迁移）的过程中，确实能够保证对外服务不中断，这是其核心设计目标之一。它主要通过以下几个关键机制来实现：

哈希槽（Hash Slot）而非节点哈希：

Redis 集群将整个键空间划分为 16384 个哈希槽。

每个键通过 CRC16(key) % 16384 计算出一个槽位号。

关键点： 集群配置映射的是槽到节点的关系，而不是键直接到节点。客户端只需要知道槽在哪个节点上即可。

槽迁移（Slot Migration）是原子操作单位：

数据迁移不是以单个键为单位，而是以哈希槽为单位进行迁移。

管理员（通常通过 redis-cli --cluster reshard 命令）指定将哪些槽从源节点迁移到目标节点（新节点）。

迁移过程中的请求处理（ASK 重定向）：

源节点（Migrating Node）： 当源节点收到一个命令请求，且该键所属的槽 X 正在迁移中（状态为 MIGRATING）时：

如果键 key 仍然存在于源节点，则源节点正常处理该命令。

如果键 key 已经被迁移到目标节点，源节点会向客户端返回一个 ASK 重定向错误 (-ASK slot X target-node-ip:target-node-port)。

客户端（Smart Client）：

一个支持集群协议的客户端（如 JedisCluster, Lettuce, redis-py-cluster 等）在收到 ASK 错误后：

会临时将后续针对这个特定键 key 的请求发送到 ASK 错误中指定的目标节点。

在发送请求到目标节点之前，客户端会先发送一个 ASKING 命令。

目标节点（Importing Node）：

目标节点收到一个命令请求时，如果该键所属的槽 X 正在迁移中（状态为 IMPORTING）：

如果请求没有伴随 ASKING 命令，目标节点会返回一个 MOVED 重定向错误 (-MOVED slot X source-node-ip:source-node-port)，告诉客户端这个槽 X 在集群配置中当前仍然归源节点管理（这是集群配置的“真相”）。

只有当请求包含 ASKING 命令时，目标节点才会临时破例接受并处理这个针对正在迁移槽 X 中的键的请求（即使配置说槽 X 还不属于它）。

目标节点处理完请求后，会正常返回结果给客户端。

迁移过程的内部机制（非阻塞）：

批量键传输： redis-cli --cluster reshard 或底层 CLUSTER SETSLOT ... MIGRATING/IMPORTING 命令会协调源节点和目标节点，以小批量的方式传输槽 X 中的键值对数据。迁移过程本身是非阻塞的，源节点和目标节点在迁移数据的同时仍然可以处理其他槽的请求。

写命令同步：

在迁移一个键的过程中（从源节点发送到目标节点），如果源节点收到对这个键的写命令：

源节点会先在本地执行这个写命令（修改本地数据）。

同时，源节点会将这个写命令缓存起来。

当这个键成功迁移到目标节点后，源节点会将缓存的针对该键的所有写命令重新发送给目标节点执行。这确保了在迁移期间发生的写操作最终也会应用到目标节点上，保证数据一致性。

原子性切换： 当槽 X 的所有键都迁移完毕，并且迁移期间缓存的写命令也都被同步到目标节点后：

管理员（或 redis-cli --cluster reshard）会发送 CLUSTER SETSLOT node-id NODE 命令给集群中的所有主节点，通知它们槽 X 的新归属（目标节点）。

所有节点更新本地集群配置。

至此，迁移完成。后续所有针对槽 X 中任何键的请求，节点都会直接返回 MOVED 重定向（指向新的目标节点），客户端会更新本地槽映射缓存。

总结保证服务不中断的关键点：

槽粒度迁移： 迁移按槽进行，一次只影响一个（或少量）槽的请求。

ASK 重定向： 处理迁移中键的临时路由。客户端根据 ASK 响应临时转向目标节点。

ASKING 命令： 目标节点只在收到 ASKING 后才处理迁移中槽的请求，避免与配置冲突。

客户端协作： 支持集群协议的客户端能正确处理 MOVED 和 ASK 重定向，自动更新连接。

增量迁移与写同步： 数据分批迁移，迁移过程中的写操作在源节点执行并同步到目标节点，保证数据一致性。

非阻塞操作： 迁移操作本身在后台进行，源节点和目标节点在迁移期间能继续处理其他槽的请求。

因此，在整个扩容和数据迁移过程中：

对于不在迁移状态槽中的数据，访问完全不受影响。

对于正在迁移槽中的数据：

如果键尚未迁移，请求在源节点处理（正常）。

如果键已经迁移，客户端会收到 ASK 重定向，并自动、临时地将请求重定向到目标节点处理（正常）。

客户端库自动处理了重定向逻辑，对业务代码通常是透明的（只要客户端库支持集群协议）。

迁移完成后，客户端通过 MOVED 重定向永久更新槽映射。

需要注意的点：

客户端兼容性： 业务使用的 Redis 客户端库必须支持 Redis 集群协议，能够正确处理 MOVED 和 ASK 重定向。大多数现代主流语言的客户端库都支持。

迁移期间性能： 迁移过程本身（数据传输、重定向）会消耗网络和 CPU 资源，可能会对集群的延迟和吞吐量产生一定影响，尤其是在迁移大量数据时。建议在业务低峰期进行扩容操作。

Pipeline/Multi-key 命令： 涉及多个键的命令（如 MGET, MSET）或事务 (MULTI/EXEC) 要求所有键必须在同一个槽。如果在迁移过程中，这些键恰好分布在迁移中的源节点和目标节点上，这类命令会失败。应用程序需要避免跨槽的多键操作或做好错误处理。

监控： 在迁移过程中，密切监控集群状态（CLUSTER NODES, CLUSTER INFO）、节点资源使用情况和客户端错误日志。

通过以上精妙的设计，Redis 集群实现了在线、平滑扩容，最大程度地保证了服务的高可用性，满足了“不能停止对外服务”的核心需求。

开启新对话
