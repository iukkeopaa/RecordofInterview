在 Redis 集群中进行节点扩容时，重新分片（resharding）过程确实需要保证服务的连续性。Redis Cluster 通过**渐进式数据迁移**和**客户端重定向**机制实现了这一目标，下面为你详细介绍：

### **1. Redis 集群的分片原理**

Redis Cluster 采用**哈希槽（Hash Slot）\**机制进行数据分片，整个集群共有\**16384 个哈希槽**。每个节点负责处理一部分哈希槽，例如：

- 3 节点集群：每个节点负责约 5461 个哈希槽（16384 ÷ 3）。
- 扩容后（如 5 节点）：每个节点负责约 3277 个哈希槽（16384 ÷ 5）。

当添加新节点后，需要将部分哈希槽从现有节点迁移到新节点。

### **2. 重新分片的核心流程**

#### **2.1 准备阶段**

1. **添加新节点**：使用`redis-cli --cluster add-node`命令将新节点加入集群。此时新节点不负责任何哈希槽，处于 “接收” 状态。
2. **规划迁移**：使用`redis-cli --cluster reshard`命令指定需要迁移的哈希槽数量和目标节点。

#### **2.2 渐进式迁移**

Redis 通过**MOVED 和 ASK 重定向**机制实现迁移期间的服务连续性：

1. **迁移哈希槽**：

   - 源节点将哈希槽标记为 “迁移中”（migrating）。
   - 目标节点将哈希槽标记为 “导入中”（importing）。

2. **数据迁移**：

   - 源节点将哈希槽中的键逐个迁移到目标节点：

     bash

     

     

     

     

     

     ```bash
     # 1. 源节点执行：查询属于该哈希槽的部分键
     CLUSTER GETKEYSINSLOT <slot> <count>
     
     # 2. 源节点执行：将键迁移到目标节点
     MIGRATE <target_ip> <target_port> <key> <db> <timeout> COPY
     ```

   - 迁移期间，源节点和目标节点同时维护这些键。

3. **客户端重定向**：

   - **MOVED 错误**：若客户端访问的键已完全迁移，源节点返回`MOVED <slot> <target_ip>:<target_port>`，客户端需更新本地路由表并重试。
   - **ASK 错误**：若客户端访问的键正在迁移中，源节点返回`ASK <slot> <target_ip>:<target_port>`，客户端需先向目标节点发送`ASKING`命令，再重试操作。

### **3. 迁移期间的请求处理**

#### **3.1 客户端请求流程**

1. **正常请求**：客户端根据本地缓存的哈希槽 - 节点映射直接访问目标节点。

2. MOVED 重定向

   ：

   - 若键已迁移，源节点返回`MOVED`错误。
   - 客户端更新本地路由表，重新向目标节点发送请求。

3. ASK 重定向

   ：

   - 若键正在迁移中，源节点返回`ASK`错误。
   - 客户端先向目标节点发送`ASKING`命令（临时允许访问导入中的哈希槽），再重试请求。

#### **3.2 节点内部处理**

- 源节点

  ：

  - 对于已迁移的键，返回`MOVED`错误。
  - 对于未迁移的键，正常处理请求。

- 目标节点

  ：

  - 对于导入中的哈希槽，仅处理带有`ASKING`标志的请求。

### **4. 关键机制详解**

#### **4.1 客户端缓存与更新**

- **本地路由表**：客户端缓存哈希槽 - 节点映射关系，减少重定向次数。
- **动态更新**：当收到`MOVED`错误时，客户端更新本地路由表。

#### **4.2 ASKING 命令的作用**

- `ASKING`命令允许客户端临时访问 “导入中” 的哈希槽，避免正常请求被拒绝。
- 该标志仅对当前连接有效，请求完成后自动清除。

#### **4.3 数据一致性保障**

- **原子性迁移**：单个键的迁移是原子性的，迁移期间不会丢失数据。
- **双写机制**：迁移过程中，源节点和目标节点同时维护数据，确保读写一致性。

### **5. 扩容操作示例**

以下是扩容 Redis 集群的典型命令流程：

bash











```bash
# 1. 添加新节点到集群
redis-cli --cluster add-node <new_node_ip:port> <existing_node_ip:port>

# 2. 执行重新分片（假设迁移1000个哈希槽到新节点）
redis-cli --cluster reshard <existing_node_ip:port> \
  --cluster-slots 1000 \
  --cluster-to <new_node_id> \
  --cluster-from <source_node_id_1>,<source_node_id_2>... \
  --cluster-yes

# 3. 可选：检查分片状态
redis-cli -c -h <node_ip> -p <port> cluster nodes
```

### **6. 性能优化建议**

1. **控制迁移速度**：通过`cluster-node-timeout`参数调整节点超时时间，避免迁移过程中断。
2. **分批迁移**：对于大规模集群，分批次迁移哈希槽，避免集中负载。
3. **监控集群状态**：使用`CLUSTER INFO`和`CLUSTER NODES`命令实时监控迁移进度。
4. **读写分离**：在迁移高峰期，将读请求导向从节点，减轻主节点压力。

### **总结**

Redis Cluster 通过以下机制保证扩容期间的服务可用性：

- **渐进式迁移**：逐个键迁移，避免一次性全量数据迁移带来的性能抖动。
- **智能重定向**：通过`MOVED`和`ASK`错误引导客户端访问正确节点。
- **双写机制**：迁移期间源节点和目标节点同时维护数据，确保一致性。





在 Redis 集群扩容（节点添加与哈希槽重分配）过程中，服务连续性的核心保障依赖于**渐进式数据迁移**、**客户端重定向机制**以及**节点状态协同**三大核心设计，具体实现如下：

### **一、核心机制：渐进式数据迁移**

Redis 的哈希槽迁移不是一次性全量迁移，而是**逐个键、分批次**进行，避免因大量数据迁移导致服务中断。

- **迁移单位**：以哈希槽为最小单位，但每个哈希槽内的键会被分批迁移（每次迁移少量键，例如通过`CLUSTER GETKEYSINSLOT <slot> <count>`指定每次迁移的键数量）。

- 双节点暂存

  ：迁移过程中，源节点（原负责哈希槽的节点）和目标节点（新节点）会

  同时保留该键的数据

  ，直到迁移完成。

  - 未迁移的键：仍由源节点正常处理读写请求。
  - 已迁移的键：目标节点接管处理，源节点不再保留。

### **二、客户端与节点的协同：重定向机制**

迁移期间，客户端可能访问到 “正在迁移的哈希槽” 或 “已迁移的哈希槽”，此时 Redis 通过**MOVED**和**ASK**两种重定向命令，引导客户端访问正确的节点，避免请求失败。

#### **1. MOVED 重定向（已完成迁移的哈希槽）**

当某个哈希槽已完全从源节点迁移到目标节点：

- 客户端若仍向源节点请求该哈希槽的键，源节点会返回`MOVED <slot> <target_ip>:<target_port>`，告知客户端该哈希槽已归属新节点。
- 客户端收到后，会**更新本地缓存的哈希槽 - 节点映射表**，后续请求直接发送到目标节点。

#### **2. ASK 重定向（正在迁移的哈希槽）**

当某个哈希槽处于 “迁移中”（部分键已迁移，部分未迁移）：

- 客户端向源节点请求该哈希槽中**已迁移的键**时，源节点会返回`ASK <slot> <target_ip>:<target_port>`，告知客户端该键已临时转移到目标节点。
- 客户端收到后，需先向目标节点发送`ASKING`命令（临时允许访问 “导入中” 的哈希槽），再重新发送请求，目标节点会处理该请求。
- 注意：`ASK`是临时重定向，客户端不会更新本地映射表，下次请求仍可能先访问源节点（直到哈希槽完全迁移，触发`MOVED`后才更新）。

### **三、节点状态标记：迁移中的权责划分**

为避免迁移期间的请求混乱，源节点和目标节点会通过状态标记明确哈希槽的处理权限：

- 源节点

  ：将正在迁移的哈希槽标记为

  ```
  migrating
  ```

  （迁移中），此时：

  - 对于未迁移的键：正常处理读写。
  - 对于已迁移的键：返回`ASK`或`MOVED`重定向。

- 目标节点

  ：将正在接收的哈希槽标记为

  ```
  importing
  ```

  （导入中），此时：

  - 仅处理带有`ASKING`标志的请求（避免其他客户端误访问）。
  - 迁移完成后，标记为`active`（正常状态），正式接管该哈希槽。

### **四、数据一致性保障**

- **原子性迁移**：单个键的迁移是原子操作（通过`MIGRATE`命令实现），迁移期间不会出现键值丢失或部分写入的情况。

- 读写不中断

  ：

  - 读请求：无论键是否迁移，通过重定向总能找到正确的节点，返回最新数据。
  - 写请求：迁移中的键会被源节点拦截并转发到目标节点（或通过重定向让客户端直接写入目标节点），确保写入的数据最终存储在正确节点。

### **总结**

Redis 集群通过 **“渐进式迁移 + 双节点暂存 + 重定向引导 + 状态标记”** 的组合机制，在扩容过程中实现了服务的连续性：

- 迁移不中断正常请求，客户端通过重定向自动适配哈希槽的新归属。
- 数据在迁移前后均能被正确读写，且无丢失风险。
- 整个过程无需停止集群，对外服务完全透明。
