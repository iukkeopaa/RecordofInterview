红黑树是一种自平衡的二叉搜索树，通过在每个节点上增加颜色标记（红色或黑色）和特定的约束条件，确保树的高度始终保持在对数级别，从而保证插入、删除和查询操作的时间复杂度为 **O(log n)**。以下是其核心实现原理：

### **1. 基本结构与性质**

红黑树在二叉搜索树（BST）的基础上，为每个节点增加了一个颜色属性，并满足以下五条性质：



1. **每个节点要么是红色，要么是黑色**。
2. **根节点是黑色**。
3. **所有叶子节点（NIL 节点，即空节点）是黑色**。
4. **如果一个节点是红色的，则它的两个子节点都是黑色的**（即不存在两个连续的红色节点）。
5. **对每个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点**（称为 “黑高”）。



这些性质确保了红黑树的最长路径不超过最短路径的两倍，从而保持平衡。

### **2. 插入操作**

插入操作分为三个步骤：



1. **按二叉搜索树规则插入新节点**，并将新节点标记为红色。
2. **修复红黑性质**：若插入导致性质被破坏，通过颜色调整和旋转操作恢复平衡。
3. **特殊处理根节点**：若插入后根节点变为红色，将其涂黑。

#### **插入修复的三种情况**

假设新插入节点为 `z`，其父节点 `p(z)` 为红色（若 `p(z)` 为黑色则无需修复）：



1. 叔叔节点为红色

   ：

   - 将父节点和叔叔节点涂黑，祖父节点涂红，然后将祖父节点作为新的 `z` 继续向上修复。

2. 叔叔节点为黑色，且 `z` 是右孩子

   ：

   - 对父节点进行左旋，转换为情况 3。

3. 叔叔节点为黑色，且 `z` 是左孩子

   ：

   - 将父节点涂黑，祖父节点涂红，然后对祖父节点进行右旋。



通过这些操作，逐步向上修复，直到性质恢复或到达根节点。

### **3. 删除操作**

删除操作同样分为三个步骤：



1. **按二叉搜索树规则删除节点**，若删除的节点有两个子节点，用其后继节点（右子树的最小节点）替代。
2. **记录被删除节点的颜色**，若被删除节点为黑色，可能破坏红黑性质，需修复。
3. **修复红黑性质**：通过颜色调整和旋转操作恢复平衡。

#### **删除修复的四种情况**

假设替代被删除节点的节点为 `x`（可能是 NIL 节点），若 `x` 为黑色，则需修复：



1. 兄弟节点为红色

   ：

   - 将兄弟节点涂黑，父节点涂红，对父节点进行左旋，转换为后续情况。

2. 兄弟节点为黑色，且其两个子节点均为黑色

   ：

   - 将兄弟节点涂红，将父节点作为新的 `x` 继续向上修复。

3. 兄弟节点为黑色，且其左子节点为红色，右子节点为黑色

   ：

   - 将兄弟节点的左子节点涂黑，兄弟节点涂红，对兄弟节点进行右旋，转换为情况 4。

4. 兄弟节点为黑色，且其右子节点为红色

   ：

   - 将兄弟节点的颜色设为父节点的颜色，父节点和兄弟节点的右子节点涂黑，对父节点进行左旋。

### **4. 旋转操作**

旋转是红黑树保持平衡的核心操作，分为左旋和右旋：



- **左旋**：将某个节点 `x` 绕其右子节点 `y` 旋转，使 `y` 成为新的父节点，`x` 成为 `y` 的左子节点。
- **右旋**：将某个节点 `y` 绕其左子节点 `x` 旋转，使 `x` 成为新的父节点，`y` 成为 `x` 的右子节点。



旋转操作仅需修改少量指针，时间复杂度为 **O(1)**，但能有效调整树的结构。

### **5. 时间复杂度与应用**

- **插入、删除、查询**：均为 **O(log n)**，因为红黑树的高度始终保持在对数级别。

- **应用场景**：广泛用于需要高效插入、删除和查询的场景，如 Java 的 `TreeMap`、C++ STL 的 `map` 和 `set`、Linux 内核的进程调度和内存管理等。

  
